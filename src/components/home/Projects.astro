---
/**
 * Projects Section - Homepage
 * 
 * Displays manually curated featured content from src/data/featured.ts
 * No auto-fetching - complete manual control over what appears here.
 */
import { getEntry } from "astro:content";
import { FEATURED_ITEMS, FEATURED_SECTIONS, type FeaturedItem } from "../../data/featured";
import { cfImageUrl } from "../../utils/api";

// Helper to normalize public paths
const normalizePublicPath = (p?: string) => (p ? p.replace(/^\/public\//, "/") : p);

// Check if a path points to a valid image (CDN URLs, /library/ paths, or any absolute path)
const hasPublicFile = (p?: string) => {
  if (!p) return false;
  if (/^https?:\/\//i.test(p)) return true;
  if (p.startsWith('/library/')) return true;
  // Any other root-relative path is assumed valid
  return p.startsWith('/');
};

// URL mapping for each collection type
const getContentUrl = (type: string, slug: string): string => {
  const urlMap: Record<string, string> = {
    photogallery: `/photogallery/${slug}`,
    essay: `/essay/${slug}`,
    longform: `/longform/${slug}`,
    post: `/post/${slug}`,
    datastory: `/datastory/${slug}`,
    code: `/code/${slug}`,
    project: `/project/${slug}`,
  };
  return urlMap[type] || `/${type}/${slug}`;
};

// Fetch content for a featured item
async function getFeaturedContent(item: FeaturedItem) {
  try {
    const entry = await getEntry(item.type, item.slug);
    if (!entry) return null;
    if ((entry.data as any).status !== "published") return null;
    
    return {
      ...item,
      entry,
      title: item.displayTitle || entry.data.title,
      subtitle: item.displaySubtitle || (entry.data as any).subtitle || (entry.data as any).description || "",
      heroImage: item.displayImage || (entry.data as any).heroImage,
      url: getContentUrl(item.type, item.slug),
    };
  } catch (e) {
    return null;
  }
}

// Determine which mode to use: flat list or sections
const useSections = FEATURED_SECTIONS.length > 0;

// Fetch all featured content
let flatItems: Awaited<ReturnType<typeof getFeaturedContent>>[] = [];
let sectionedItems: { title: string; items: Awaited<ReturnType<typeof getFeaturedContent>>[] }[] = [];

if (useSections) {
  // Grouped by sections
  for (const section of FEATURED_SECTIONS) {
    const items = await Promise.all(section.items.map(getFeaturedContent));
    sectionedItems.push({
      title: section.title,
      items: items.filter(Boolean),
    });
  }
} else {
  // Flat list
  flatItems = (await Promise.all(FEATURED_ITEMS.map(getFeaturedContent))).filter(Boolean);
}

// Type icons for each content type
const typeIcons: Record<string, string> = {
  post: "‚úèÔ∏è",
  essay: "üìù",
  longform: "üìñ",
  photogallery: "üì∑",
  code: "üíª",
  datastory: "üìä",
  project: "üéØ",
};
---

<section id="projects" class="projects">
  <header class="projects-header">
    <h2 class="projects-title">The Projects</h2>
  </header>

  {useSections ? (
    <!-- SECTIONED LAYOUT -->
    <>
    {sectionedItems.map((section) => section.items.length > 0 && (
      <div class="projects-section">
        <div class="projects-label">{section.title}</div>
        <div class="projects-row">
          {section.items.map((item) => item && (
            <article class={`project-card ${item.type}-card`}>
              <a href={item.url}>
                <div class="card-media">
                  {(() => {
                    const heroSrc = normalizePublicPath(item.heroImage);
                    const optimizedSrc = heroSrc?.startsWith('/library/') ? cfImageUrl(heroSrc, 600) : heroSrc;
                    return heroSrc && (heroSrc.startsWith('http') || hasPublicFile(heroSrc)) ? (
                      <img src={optimizedSrc} alt={item.title} loading="lazy" decoding="async" />
                    ) : (
                      <div class="card-placeholder-icon">
                        <span>{typeIcons[item.type] || "üìÑ"}</span>
                      </div>
                    );
                  })()}
                  {item.label && <span class="card-label">{item.label}</span>}
                </div>
                <div class="card-content">
                  <h3>{item.title}</h3>
                  <p>{item.subtitle}</p>
                </div>
              </a>
            </article>
          ))}
        </div>
      </div>
    ))}
    </>
  ) : (
    <!-- FLAT LAYOUT -->
    <>
    {flatItems.length > 0 ? (
      <div class="projects-section">
        <div class="projects-row projects-row--flat">
          {flatItems.map((item) => item && (
            <article class={`project-card ${item.type}-card`}>
              <a href={item.url}>
                <div class="card-media">
                  {(() => {
                    const heroSrc = normalizePublicPath(item.heroImage);
                    const optimizedSrc = heroSrc?.startsWith('/library/') ? cfImageUrl(heroSrc, 600) : heroSrc;
                    return heroSrc && (heroSrc.startsWith('http') || hasPublicFile(heroSrc)) ? (
                      <img src={optimizedSrc} alt={item.title} loading="lazy" decoding="async" />
                    ) : (
                      <div class="card-placeholder-icon">
                        <span>{typeIcons[item.type] || "üìÑ"}</span>
                      </div>
                    );
                  })()}
                  {item.label && <span class="card-label">{item.label}</span>}
                </div>
                <div class="card-content">
                  <span class="card-type">{item.type}</span>
                  <h3>{item.title}</h3>
                  <p>{item.subtitle}</p>
                  <span class="read-more">View ‚Üí</span>
                </div>
              </a>
            </article>
          ))}
        </div>
      </div>
    ) : (
      <div class="projects-empty">
        <p>No featured content yet. Add items to <code>src/data/featured.ts</code></p>
      </div>
    )}
    </>
  )}
</section>
