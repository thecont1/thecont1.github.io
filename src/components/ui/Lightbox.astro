---
/* 
  Lightbox Component
  - Auto-attaches to images within a specified selector or globally if none provided.
  - Handles opening, closing, and basic accessibility.
*/
import "../../styles/lightbox.css";
import IconBulb from "../icons/IconBulb.astro";
import IconCR from "../icons/IconCR.astro";

interface Props {
  selector?: string; // CSS selector to scope image listeners (e.g., '.post-content')
  gallery?: boolean; // Whether to allow cycling through images
}

const { selector = "main", gallery = true } = Astro.props;
---

<div id="lightbox" class="lightbox" aria-hidden="true" data-selector={selector} data-gallery={gallery.toString()}>
  <div class="lightbox-overlay"></div>
  
  <div class="lightbox-main">
    <figure class="lightbox-figure">
      <img id="lightbox-img" class="lightbox-img" src="" alt="" />
      <img id="lightbox-img-2" class="lightbox-img" src="" alt="" />
    </figure>
  </div>

  <aside class="lightbox-sidebar">
    <div class="sidebar-content">
      <div id="lightbox-meta" class="lightbox-meta">
        <h3 id="lightbox-caption" class="lightbox-caption"></h3>
        <div id="lightbox-exif" class="lightbox-exif"></div>
      </div>
    </div>

    <div class="sidebar-footer">
      <div class="control-group">
        {gallery && (
          <>
            <button id="lightbox-prev" class="icon-btn" aria-label="Previous image">
               <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
            </button>
            <button id="lightbox-next" class="icon-btn" aria-label="Next image">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
            </button>
          </>
        )}
        <button id="toggle-lights" class="icon-btn" aria-label="Toggle Lights">
          <IconBulb />
        </button>
        <button id="lightbox-c2pa" class="icon-btn" aria-label="View Content Credentials">
          <IconCR width="20" height="20" />
        </button>
        <button id="lightbox-close" class="icon-btn" aria-label="Close">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
      </div>
    </div>
  </aside>
</div>

<script>
  console.log('=== LIGHTBOX SCRIPT STARTING ===');

  const lightbox = document.getElementById("lightbox");
  const gallery = lightbox?.dataset.gallery === "true";
  const selector = lightbox?.dataset.selector || "main";
  const lightboxImages = document.querySelectorAll(".lightbox-img");
  const caption = document.getElementById("lightbox-caption");
  const closeBtn = document.getElementById("lightbox-close");
  const prevBtn = document.getElementById("lightbox-prev");
  const nextBtn = document.getElementById("lightbox-next");
  const overlay = document.querySelector(".lightbox-overlay");
  const toggleLightsBtn = document.getElementById("toggle-lights");
  const metaContainer = document.getElementById("lightbox-meta");
  const exifContainer = document.getElementById("lightbox-exif");
  const c2paBtn = document.getElementById("lightbox-c2pa");

  let currentImages = [];
  let currentIndex = -1;
  let activeImgIndex = 0;
  let isTransitioning = false;

  const getMetadata = async (imgUrl) => {
    console.log('Getting comprehensive metadata for:', imgUrl);
    
    try {
      // Extract the path from the URL (remove domain/port)
      const url = new URL(imgUrl);
      const imagePath = url.pathname;
      
      console.log('Looking up pre-extracted EXIF data for path:', imagePath);
      
      // Parse the directory structure from the path
      // e.g., /library/originals/TheAfricanPortraits/image.jpg -> TheAfricanPortraits
      const pathParts = imagePath.split('/');
      const filename = pathParts[pathParts.length - 1];
      
      // Find the directory (should be the part after 'originals')
      const originalsIndex = pathParts.indexOf('originals');
      if (originalsIndex === -1 || originalsIndex >= pathParts.length - 2) {
        console.log('Could not determine directory from path:', imagePath);
        return {};
      }
      
      const directory = pathParts[originalsIndex + 1];
      console.log('Determined directory:', directory, 'filename:', filename);
      
      // Fetch the co-located metadata JSON from the same directory as the images
      const metadataUrl = `/library/originals/${directory}/metadata.json`;
      console.log('Fetching metadata from:', metadataUrl);
      
      const response = await fetch(metadataUrl);
      if (!response.ok) {
        throw new Error(`Failed to load metadata from ${metadataUrl}: ${response.status}`);
      }
      
      const directoryMetadata = await response.json();
      const metadata = directoryMetadata[filename];
      
      if (metadata) {
        console.log('Found pre-extracted metadata:', Object.keys(metadata));
        return metadata;
      } else {
        console.log('No pre-extracted metadata found for:', filename);
        console.log('Available files in directory (first 5):', Object.keys(directoryMetadata).slice(0, 5));
        return {};
      }
      
    } catch (e) {
      console.warn('Metadata lookup error:', e);
      return {};
    }
  };

  const formatShutterSpeed = (exposureTime) => {
    if (!exposureTime) return '';
    const val = exposureTime.value || exposureTime;
    if (typeof val === 'number') {
      if (val >= 1) return val.toFixed(1) + 's';
      const denominator = Math.round(1 / val);
      return denominator > 0 ? `1/${denominator}s` : `${val}s`;
    }
    return exposureTime.description || String(val);
  };

  if (lightbox && lightboxImages.length === 2 && caption && closeBtn && overlay) {
    console.log('=== LIGHTBOX SCRIPT LOADED ===');
    console.log('Lightbox script initialized successfully');
    console.log('Gallery mode:', gallery);
    console.log('Selector:', selector);

    const updateCaptionAndMeta = async (targetImgEl) => {
      // 1. Basic Title/Caption from figure or alt
      let capText = "";
      const fig = targetImgEl.closest("figure");
      if (fig) {
        const cap = fig.querySelector("figcaption");
        if (cap) capText = cap.textContent;
      }
      
      // If no figcaption, we'll try to get it from EXIF ImageDescription later
      let initialCaption = capText || targetImgEl.alt || "Untitled";
      caption.textContent = initialCaption;

      // 2. EXIF/IPTC Metadata
      if (exifContainer) {
        exifContainer.innerHTML = '<p class="loading-meta">Fetching metadata...</p>';
        
        try {
          const data = await getMetadata(targetImgEl.src);
          
          // Update caption with EXIF ImageDescription if no figcaption was found
          if (!capText && data && data.exif && data.exif.ImageDescription) {
            const imageDesc = data.exif.ImageDescription;
            if (imageDesc && imageDesc.length > 10) { // Only use if it's substantial
              caption.textContent = imageDesc;
            }
          }
          
          if (data && !data.error && (data.exif || data.photography)) {
            let exifHtml = '';
            
            // Display photography data (processed/formatted)
            if (data.photography) {
              const photo = data.photography;
              
              if (photo.camera_make || photo.camera_model) {
                let cameraInfo = '';
                if (photo.camera_make && photo.camera_model) {
                  cameraInfo = `${photo.camera_make} ${photo.camera_model}`;
                } else {
                  cameraInfo = photo.camera_make || photo.camera_model;
                }
                exifHtml += `<p class="exif-row"><strong>Camera:</strong> ${cameraInfo}</p>`;
              }
              
              if (photo.lens_model) {
                exifHtml += `<p class="exif-row"><strong>Lens:</strong> ${photo.lens_model}</p>`;
              }
              
              // Camera settings
              const settings = [
                photo.shutter_speed,
                photo.aperture,
                photo.iso ? `ISO ${photo.iso}` : '',
                photo.focal_length
              ].filter(Boolean).join('  •  ');
              
              if (settings) {
                exifHtml += `<p class="exif-row"><strong>Settings:</strong> ${settings}</p>`;
              }
              
              if (photo.date_taken || photo.date_original) {
                const date = photo.date_original || photo.date_taken;
                exifHtml += `<p class="exif-row"><strong>Date Taken:</strong> ${date}</p>`;
              }
              
              if (photo.artist) {
                exifHtml += `<p class="exif-row"><strong>Artist:</strong> ${photo.artist}</p>`;
              }
              
              if (photo.copyright) {
                exifHtml += `<p class="exif-row"><strong>Copyright:</strong> ${photo.copyright}</p>`;
              }
            }
            
            // Add basic image info
            if (data.width && data.height) {
              exifHtml += `<p class="exif-row"><strong>Dimensions:</strong> ${data.width} × ${data.height}</p>`;
            }
            
            if (data.format) {
              exifHtml += `<p class="exif-row"><strong>Format:</strong> ${data.format}</p>`;
            }
            
            exifContainer.innerHTML = exifHtml || `<p class="exif-row"><strong>Dimensions:</strong> ${targetImgEl.naturalWidth} × ${targetImgEl.naturalHeight}</p>`;
          } else {
            // Fallback to basic info
            exifContainer.innerHTML = `
              <p class="exif-row"><strong>Dimensions:</strong> ${targetImgEl.naturalWidth} x ${targetImgEl.naturalHeight}</p>
              <p class="exif-row"><strong>Format:</strong> ${targetImgEl.src.split('.').pop().toUpperCase()}</p>
            `;
          }
        } catch (err) {
          console.error('Metadata update error:', err);
          exifContainer.innerHTML = `<p>Metadata unavailable</p>`;
        }
      }
    };

    const updateLightbox = (index, withTransition = false) => {
      if (index < 0 || index >= currentImages.length) return;
      
      const target = currentImages[index];
      
      // Determine orientation for sizing
      const isVertical = target.naturalHeight > target.naturalWidth;
      lightbox.setAttribute("data-orientation", isVertical ? "vertical" : "horizontal");

      const currentImgEl = lightboxImages[activeImgIndex];

      if (withTransition && !isTransitioning) {
        isTransitioning = true;
        
        // Phase 1: Fade Out
        currentImgEl.style.opacity = '0';
        
        setTimeout(() => {
            // Phase 2: Swap Source (while invisible)
            currentImgEl.src = target.src;
            currentImgEl.alt = target.alt || "";
            
            // Preload next image while we wait
            const lookaheadIndex = (index + 1) % currentImages.length;
            if (lookaheadIndex !== index) {
                const preloadImg = new Image();
                preloadImg.src = currentImages[lookaheadIndex].src;
            }

            // Ensure image is loaded before fading in and updating meta
            const completeTransition = () => {
                // Important: Metadata must be extracted from the element that has the source
                updateCaptionAndMeta(currentImgEl);
                
                // Phase 3: Fade In
                requestAnimationFrame(() => {
                    currentImgEl.style.opacity = '1';
                    setTimeout(() => {
                        isTransitioning = false;
                    }, 300); // Match CSS transition
                });
            };

            if (currentImgEl.complete) {
                completeTransition();
            } else {
                currentImgEl.onload = completeTransition;
                currentImgEl.onerror = () => {
                    console.error('Failed to load image');
                    isTransitioning = false;
                };
            }
        }, 300); // Wait for fade out to finish

      } else {
        // Instant update (first load)
        currentImgEl.style.opacity = '0'; // Start hidden to prevent flash
        currentImgEl.src = target.src;
        currentImgEl.alt = target.alt || "";
        
        const showImage = () => {
            updateCaptionAndMeta(currentImgEl);
            currentImgEl.style.opacity = '1';
            
            // Preload next
            const lookaheadIndex = (index + 1) % currentImages.length;
            if (lookaheadIndex !== index && currentImages.length > 0) {
                 const preloadImg = new Image();
                 preloadImg.src = currentImages[lookaheadIndex].src;
            }
        };

        if (currentImgEl.complete) {
            requestAnimationFrame(showImage);
        } else {
            currentImgEl.onload = showImage;
        }
      }

      currentIndex = index;
    };

    // Add click-to-next on the images themselves
    lightboxImages.forEach(imgEl => {
        imgEl.addEventListener('click', (e) => {
            e.stopPropagation();
            // Only advance if gallery mode is active (single images shouldn't cycle endlessly unless desired)
            if (gallery && currentImages.length > 1) {
                nextImage();
            }
        });
        // Add pointer cursor to indicate clickability
        imgEl.style.cursor = gallery ? "pointer" : "default";
    });

    if (toggleLightsBtn && metaContainer) {
      toggleLightsBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const isLightsOn = lightbox.classList.toggle("lights-on");
        const isLightsOff = !isLightsOn;
        
        if (isLightsOff) {
          lightbox.classList.add("lights-off");
          // Keep meta active in both modes, CSS handles styling
          metaContainer.classList.add("is-active"); 
          toggleLightsBtn.classList.remove("active");
        } else {
          lightbox.classList.remove("lights-off");
          metaContainer.classList.add("is-active");
          toggleLightsBtn.classList.add("active");
        }
      });
    }

    const openLightbox = (imageElement) => {
      console.log('openLightbox called', { gallery });
      // If gallery is false, do nothing (should be handled by attachListeners not adding events, but safety check)
      if (!gallery) return;

      const container = document.querySelector(selector);
      if (!container) {
          console.error('Lightbox container not found:', selector);
          return;
      }
      currentImages = Array.from(container.querySelectorAll("img")).filter(i => {
        return !i.closest("a") && !i.classList.contains("no-lightbox");
      });
      console.log('Found images:', currentImages.length);
      currentIndex = currentImages.indexOf(imageElement);
      console.log('Current index:', currentIndex);

      if (currentIndex === -1) {
          console.error('Clicked image not found in currentImages list');
          return;
      }

      // Reset state for clean open
      lightboxImages.forEach(img => {
        img.classList.remove('active', 'next');
        img.removeAttribute('src'); // Use removeAttribute instead of src="" to avoid self-fetch
      });
      activeImgIndex = 0; // Reset to first slot

      updateLightbox(currentIndex, false); 
      lightbox.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";
      document.body.classList.add("lightbox-open");
      document.body.classList.add("toc-hidden");
      
      // Default state: Lights On
      lightbox.classList.add("lights-on");
      lightbox.classList.remove("lights-off");
      if (metaContainer) metaContainer.classList.add("is-active");
      if (toggleLightsBtn) toggleLightsBtn.classList.add("active");
    };

    const closeLightbox = () => {
      lightbox.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";
      document.body.classList.remove("lightbox-open");
      document.body.classList.remove("toc-hidden");
      
      // Reset image state after close animation
      setTimeout(() => {
          lightboxImages.forEach(img => {
            img.removeAttribute('src');
            img.classList.remove('active', 'next');
          });
          isTransitioning = false;
      }, 300);
    };

    // Close when clicking main area or overlay
    const mainArea = document.querySelector(".lightbox-main");
    if (mainArea) {
      mainArea.addEventListener("click", (e) => {
        if (e.target === mainArea || e.target === document.querySelector(".lightbox-figure")) {
          closeLightbox();
        }
      });
    }

    const nextImage = () => {
      if (isTransitioning) return;
      if (currentIndex < currentImages.length - 1) {
        updateLightbox(currentIndex + 1, true);
      } else if (currentImages.length > 1) {
        updateLightbox(0, true); // Loop to start
      }
    };

    const prevImage = () => {
      if (isTransitioning) return;
      if (currentIndex > 0) {
        updateLightbox(currentIndex - 1, true);
      } else if (currentImages.length > 1) {
        updateLightbox(currentImages.length - 1, true); // Loop to end
      }
    };

    const attachListeners = () => {
      console.log('=== LIGHTBOX ATTACH LISTENERS ===');
      console.log('Gallery enabled:', gallery);
      console.log('Selector:', selector);
      
      if (!gallery) return; // Disable lightbox if gallery is false

      const container = document.querySelector(selector);
      console.log('Container found:', !!container);
      if (!container) return;

      const images = container.querySelectorAll("img");
      console.log('Images to attach listeners to:', images.length);
      
      images.forEach((image, index) => {
        if (image.closest("a")) return;
        if (image.classList.contains("no-lightbox")) return;

        console.log(`Attaching click listener to image ${index}`);
        image.style.cursor = "zoom-in";
        image.addEventListener("click", (e) => {
          console.log('=== LIGHTBOX CLICK DETECTED ===');
          console.log('Clicked image:', image.src);
          e.stopPropagation();
          openLightbox(image);
        });
      });
      
      console.log('=== LIGHTBOX LISTENERS ATTACHED ===');
    };

    attachListeners();
    document.addEventListener("astro:page-load", attachListeners);

    closeBtn.addEventListener("click", closeLightbox);
    overlay.addEventListener("click", closeLightbox);
    
    if (gallery && prevBtn && nextBtn) {
      prevBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        prevImage();
      });
      nextBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        nextImage();
      });
    }

    if (c2paBtn) {
      c2paBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        console.log('=== C2PA BUTTON CLICKED ===');
        const currentImgEl = lightboxImages[activeImgIndex];
        const imgSrc = currentImgEl?.src;
        console.log('Current image src:', imgSrc);
        if (imgSrc) {
          console.log('Dispatching open-c2pa event');
          window.dispatchEvent(new CustomEvent('open-c2pa', { detail: { imgSrc } }));
        } else {
          console.log('No image src found');
        }
      });
    } else {
      console.log('C2PA button not found');
    }

    document.addEventListener("keydown", (e) => {
      if (lightbox.getAttribute("aria-hidden") === "true") return;

      if (e.key === "Escape") closeLightbox();
      if (gallery) {
        if (e.key === "ArrowRight") nextImage();
        if (e.key === "ArrowLeft") prevImage();
      }
    });
  }
</script>
