---
import type { CollectionEntry } from "astro:content";
import Layout from "../../layouts/Layout.astro";
import Lightbox from "../ui/Lightbox.astro";
import C2PAOverlay from "../ui/C2PAOverlay.astro";
import Carousel from "../carousel/Carousel.tsx";
import "../../styles/photogallery.css";
import "../../styles/carousel.css";
import "../../styles/info-panel.css";

interface Props {
  post: CollectionEntry<"photogallery">;
}

const { post } = Astro.props;

// Get collection name dynamically
const collectionName = "Photogallery";

// Use images from frontmatter
const images = post.data.images || [];

// Layout type - default to "tile" if not specified
const layoutType = post.data.layoutType || "tile";

// Lightbox enabled by default, can be disabled via frontmatter
const lightboxEnabled = post.data.lightbox?.gallery !== false;

const backgroundColor = post.data.backgroundColor || "#FAF9F6";

// Format date if available
const formattedDate = post.data.date ? new Intl.DateTimeFormat('en-US', {
  year: 'numeric',
  month: 'long',
  day: 'numeric'
}).format(post.data.date) : null;

function getOriginalsDirFromSrc(imgSrc: string): string | null {
  const parts = imgSrc.split('/').filter(Boolean);
  const originalsIndex = parts.indexOf('originals');
  if (originalsIndex === -1) return null;
  if (originalsIndex >= parts.length - 2) return null;
  return parts.slice(0, parts.length - 1).join('/');
}
const dirMetadataCache = new Map<string, any>();

async function loadMetadataForDir(dirPathFromWebRoot: string): Promise<any> {
  // Expecting a web-root-like path that includes /originals/<DIR>
  const parts = dirPathFromWebRoot.split('/').filter(Boolean);
  const originalsIndex = parts.indexOf('originals');
  if (originalsIndex === -1 || originalsIndex >= parts.length) return null;
  const directory = parts[originalsIndex + 1];
  if (!directory) return null;

  if (dirMetadataCache.has(directory)) return dirMetadataCache.get(directory);
  try {
    const metadataUrl = `/library/originals/${directory}/metadata.json`;
    const resp = await fetch(metadataUrl);
    const data = resp.ok ? await resp.json() : null;
    dirMetadataCache.set(directory, data);
    return data;
  } catch {
    dirMetadataCache.set(directory, null);
    return null;
  }
}
---

{layoutType === "carousel" ? (
  <!-- CAROUSEL LAYOUT - Full page with curtain, then footer -->
  <Layout title={post.data.title}>
    <Fragment slot="head">
      {images.slice(0, 3).map((img) => (
        <link rel="preload" as="image" href={img.src} />
      ))}
    </Fragment>
    <section class="photogallery-carousel-hero">
      <!-- Fixed carousel layer -->
      <div class="carousel-hero-fixed">
        <Carousel 
          images={await Promise.all(images.map(async (img) => {
            const filename = img.src.split('/').pop() || '';
            const dir = getOriginalsDirFromSrc(img.src);
            let meta: any = {};
            if (dir) {
              const dirMeta = await loadMetadataForDir(dir);
              meta = dirMeta?.[filename]?.photography || {};
            }
            return {
              src: img.src,
              caption: img.caption,
              metadata: meta
            };
          }))}
          client:load
        />
      </div>

      <!-- Curtain with title/subtitle/category - uses backgroundColor with transparency -->
      <div class="carousel-curtain" style={`--curtain-bg: ${backgroundColor};`}>
        <div class="carousel-curtain-content">
          <span class="carousel-curtain-category">{collectionName}</span>
          <h1 class="carousel-curtain-title">{post.data.title}</h1>
          {post.data.subtitle && (
            <p class="carousel-curtain-subtitle">{post.data.subtitle}</p>
          )}
        </div>
      </div>
    </section>

    <!-- Creates space for curtain lift -->
    <div class="carousel-scroll-runway"></div>

    <!-- Small buffer to push carousel up for footer -->
    <div class="carousel-scroll-buffer"></div>

    <!-- C2PA Overlay -->
    <C2PAOverlay />
  </Layout>
) : (
  <!-- REGULAR PHOTOGALLERY LAYOUTS (tile/one-up) -->
  <Layout title={post.data.title}>
    <div class="photogallery-layout" style={`--page-bg: ${backgroundColor};`}>
      
      <!-- Header Section -->
      <header class="photogallery-header">
        <div class="photogallery-meta-top">
          {post.data.category && <span class="category">{post.data.category}</span>}
          {formattedDate && <time datetime={post.data.date?.toISOString()}>{formattedDate}</time>}
        </div>
        
        <h1 class="photogallery-title">{post.data.title}</h1>
        
        <div class="photogallery-author-line">
          <span class="by">by</span>
          <span class="author-name">{post.data.author}</span>
        </div>

        {post.data.subtitle && <p class="photogallery-subtitle">{post.data.subtitle}</p>}
      </header>

      <!-- Gallery Content -->
      {layoutType === "one-up" ? (
        <!-- ONE-UP LAYOUT -->
        <div class="photogallery-oneup">
          {images.map((img) => (
            <figure class="gallery-item">
              <img src={img.src} alt={img.alt || img.caption || ""} loading="lazy" />
              {img.caption && <figcaption>{img.caption}</figcaption>}
            </figure>
          ))}
          {images.length === 0 && (
            <div class="no-images">
              <p>No images specified in frontmatter</p>
            </div>
          )}
        </div>
      ) : (
        <!-- GRID LAYOUT (tile) - Default -->
        <div class="photogallery-grid">
          {images.map((img) => (
            <figure class="gallery-item">
              <img src={img.src} alt={img.alt || img.caption || ""} loading="lazy" />
              {img.caption && <figcaption>{img.caption}</figcaption>}
            </figure>
          ))}
          {images.length === 0 && (
            <div class="no-images">
              <p>No images specified in frontmatter</p>
            </div>
          )}
        </div>
      )}

      <!-- Content below gallery -->
      <div class="photogallery-content">
        <slot />
      </div>

      <!-- Lightbox (enabled by default) -->
      {lightboxEnabled && (
        <Lightbox 
          selector=".photogallery-layout" 
          gallery={true} 
        />
      )}

      <!-- C2PA Overlay -->
      <C2PAOverlay />
    </div>
  </Layout>
)}

<script>
  function refinePhotogalleryContent() {
    const layout = document.querySelector('.photogallery-layout') as HTMLElement;
    const isCarousel = document.querySelector('.photogallery-carousel-hero');
    const header = document.querySelector('.site-header') as HTMLElement;
    
    if (isCarousel) {
      // Add class to body for carousel styles
      document.body.classList.add('photogallery-carousel');
      
      // Keep header transparent for carousel
      if (header) {
        header.style.backgroundColor = 'transparent';
        header.style.transition = 'background-color 0.3s ease';
        
        const headerInner = header.querySelector('.site-header-inner') as HTMLElement;
        if (headerInner) headerInner.style.backgroundColor = 'transparent';
      }
      
      // Scroll handler for curtain, controls, and carousel lift
      const carouselFixed = document.querySelector('.carousel-hero-fixed') as HTMLElement;
      const curtain = document.querySelector('.carousel-curtain') as HTMLElement;
      
      // Check if browser supports scroll-driven animations
      const supportsScrollTimeline = CSS.supports('animation-timeline: scroll()');
      
      let ticking = false;
      
      const onScroll = () => {
        if (ticking) return;
        ticking = true;
        
        window.requestAnimationFrame(() => {
          const scrollY = window.scrollY;
          const vh = window.innerHeight;
          
          // Controls appear at 100vh (after curtain lifts)
          // Controls disappear at 80vh (giving delay before curtain returns)
          if (scrollY >= vh) {
            document.body.classList.add('controls-visible');
          } else if (scrollY < vh * 0.8) {
            document.body.classList.remove('controls-visible');
          }
          
          // Only do manual transforms if browser doesn't support scroll-driven animations
          if (!supportsScrollTimeline) {
            // Curtain lifts faster (0 to 100vh instead of 120vh)
            if (curtain) {
              const curtainProgress = Math.min(1, scrollY / vh);
              curtain.style.transform = `translateY(${-curtainProgress * 120}vh)`;
            }
            
            // Carousel shifts up to make room for footer (220vh to 250vh)
            if (carouselFixed) {
              const startShift = vh * 2.2;
              const endShift = vh * 2.5;
              
              if (scrollY < startShift) {
                carouselFixed.style.transform = 'translateY(0)';
              } else if (scrollY >= endShift) {
                carouselFixed.style.transform = 'translateY(-15vh)';
              } else {
                const progress = (scrollY - startShift) / (endShift - startShift);
                carouselFixed.style.transform = `translateY(${-progress * 15}vh)`;
              }
            }
          }
          
          ticking = false;
        });
      };
      
      window.addEventListener('scroll', onScroll, { passive: true });
      onScroll(); // Run once on load
      
    } else if (layout) {
      // Regular photogallery layout
      const bgColor = getComputedStyle(layout).getPropertyValue('--page-bg');
      
      if (header) {
        header.style.backgroundColor = bgColor;
        header.style.transition = 'background-color 0.3s ease';
        
        const headerInner = header.querySelector('.site-header-inner') as HTMLElement;
        if (headerInner) headerInner.style.backgroundColor = 'transparent';
      }
      
      // Auto-scroll to position category in header center for tile/one-up layouts
      const category = document.querySelector('.photogallery-meta-top .category') as HTMLElement;
      if (category && header) {
        // Wait a bit for page to fully load
        setTimeout(() => {
          const headerHeight = header.offsetHeight;
          const categoryRect = category.getBoundingClientRect();
          const categoryTop = categoryRect.top + window.scrollY;
          
          // Calculate scroll position to center category in header
          const targetScroll = categoryTop - (headerHeight / 2) + (categoryRect.height / 2);
          
          // Smooth scroll to position
          window.scrollTo({
            top: Math.max(0, targetScroll),
            behavior: 'smooth'
          });
        }, 100);
      }
    }
  }

  refinePhotogalleryContent();
  document.addEventListener('astro:page-load', refinePhotogalleryContent);
</script>